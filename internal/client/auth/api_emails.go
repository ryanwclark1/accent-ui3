/*
accent-auth

Accent's authentication service

API version: 0.1
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package auth

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type EmailsAPI interface {

	/*
		GetEmailConfirm Confirm an email address

		**Required ACL**: `auth.emails.{email_uuid}.confirm.edit` The token should be in the URL instead of being in the HTTP headers

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param emailUuid The UUID of the email
		@return EmailsAPIGetEmailConfirmRequest
	*/
	GetEmailConfirm(ctx context.Context, emailUuid string) EmailsAPIGetEmailConfirmRequest

	// GetEmailConfirmExecute executes the request
	GetEmailConfirmExecute(r EmailsAPIGetEmailConfirmRequest) (*http.Response, error)

	/*
		GetNewEmailConfirmation Ask a new confirmation email

		**Required ACL**: `auth.users.{user_uuid}.emails.{email_uuid}.confirm.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid The UUID of the user
		@param emailUuid The UUID of the email
		@return EmailsAPIGetNewEmailConfirmationRequest
	*/
	GetNewEmailConfirmation(ctx context.Context, userUuid string, emailUuid string) EmailsAPIGetNewEmailConfirmationRequest

	// GetNewEmailConfirmationExecute executes the request
	GetNewEmailConfirmationExecute(r EmailsAPIGetNewEmailConfirmationRequest) (*http.Response, error)

	/*
		PutEmailConfirm Confirm an email address

		**Required ACL**: `auth.emails.{email_uuid}.confirm.edit`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param emailUuid The UUID of the email
		@return EmailsAPIPutEmailConfirmRequest
	*/
	PutEmailConfirm(ctx context.Context, emailUuid string) EmailsAPIPutEmailConfirmRequest

	// PutEmailConfirmExecute executes the request
	PutEmailConfirmExecute(r EmailsAPIPutEmailConfirmRequest) (*http.Response, error)

	/*
		UpdateAllUserEmails Update email addresses

		**Required ACL**: `auth.admin.users.{user_uuid}.emails.edit` Update all of the users email address at the same time.
	If an existing address is missing from the list, it will be removed. An empty list will remove all addresses. If addresses are defined, one and only one address should be main. If the confirmed field is set to none or ommited the existing value will be reused if it exists, otherwise the address will not be confirmed.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid The UUID of the user
		@return EmailsAPIUpdateAllUserEmailsRequest
	*/
	UpdateAllUserEmails(ctx context.Context, userUuid string) EmailsAPIUpdateAllUserEmailsRequest

	// UpdateAllUserEmailsExecute executes the request
	UpdateAllUserEmailsExecute(r EmailsAPIUpdateAllUserEmailsRequest) (*http.Response, error)

	/*
		UpdateUserEmails Update email addresses

		**Required ACL**: `auth.users.{user_uuid}.emails.edit` Update all of the users email address at the same time.
	If an existing address is missing from the list, it will be removed. An empty list will remove all addresses. If addresses are defined, one and only one address should be main. All new address are created unconfirmed.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid The UUID of the user
		@return EmailsAPIUpdateUserEmailsRequest
	*/
	UpdateUserEmails(ctx context.Context, userUuid string) EmailsAPIUpdateUserEmailsRequest

	// UpdateUserEmailsExecute executes the request
	UpdateUserEmailsExecute(r EmailsAPIUpdateUserEmailsRequest) (*http.Response, error)
}

// EmailsAPIService EmailsAPI service
type EmailsAPIService service

type EmailsAPIGetEmailConfirmRequest struct {
	ctx        context.Context
	ApiService EmailsAPI
	emailUuid  string
	token      *string
}

// The UUID of the token used to confirm the email address
func (r EmailsAPIGetEmailConfirmRequest) Token(token string) EmailsAPIGetEmailConfirmRequest {
	r.token = &token
	return r
}

func (r EmailsAPIGetEmailConfirmRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEmailConfirmExecute(r)
}

/*
GetEmailConfirm Confirm an email address

**Required ACL**: `auth.emails.{email_uuid}.confirm.edit` The token should be in the URL instead of being in the HTTP headers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param emailUuid The UUID of the email
	@return EmailsAPIGetEmailConfirmRequest
*/
func (a *EmailsAPIService) GetEmailConfirm(ctx context.Context, emailUuid string) EmailsAPIGetEmailConfirmRequest {
	return EmailsAPIGetEmailConfirmRequest{
		ApiService: a,
		ctx:        ctx,
		emailUuid:  emailUuid,
	}
}

// Execute executes the request
func (a *EmailsAPIService) GetEmailConfirmExecute(r EmailsAPIGetEmailConfirmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmailsAPIService.GetEmailConfirm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/emails/{email_uuid}/confirm"
	localVarPath = strings.Replace(localVarPath, "{"+"email_uuid"+"}", url.PathEscape(parameterValueToString(r.emailUuid, "emailUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return nil, reportError("token is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EmailsAPIGetNewEmailConfirmationRequest struct {
	ctx        context.Context
	ApiService EmailsAPI
	userUuid   string
	emailUuid  string
}

func (r EmailsAPIGetNewEmailConfirmationRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetNewEmailConfirmationExecute(r)
}

/*
GetNewEmailConfirmation Ask a new confirmation email

**Required ACL**: `auth.users.{user_uuid}.emails.{email_uuid}.confirm.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid The UUID of the user
	@param emailUuid The UUID of the email
	@return EmailsAPIGetNewEmailConfirmationRequest
*/
func (a *EmailsAPIService) GetNewEmailConfirmation(ctx context.Context, userUuid string, emailUuid string) EmailsAPIGetNewEmailConfirmationRequest {
	return EmailsAPIGetNewEmailConfirmationRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
		emailUuid:  emailUuid,
	}
}

// Execute executes the request
func (a *EmailsAPIService) GetNewEmailConfirmationExecute(r EmailsAPIGetNewEmailConfirmationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmailsAPIService.GetNewEmailConfirmation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/emails/{email_uuid}/confirm"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"email_uuid"+"}", url.PathEscape(parameterValueToString(r.emailUuid, "emailUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EmailsAPIPutEmailConfirmRequest struct {
	ctx        context.Context
	ApiService EmailsAPI
	emailUuid  string
}

func (r EmailsAPIPutEmailConfirmRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutEmailConfirmExecute(r)
}

/*
PutEmailConfirm Confirm an email address

**Required ACL**: `auth.emails.{email_uuid}.confirm.edit`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param emailUuid The UUID of the email
	@return EmailsAPIPutEmailConfirmRequest
*/
func (a *EmailsAPIService) PutEmailConfirm(ctx context.Context, emailUuid string) EmailsAPIPutEmailConfirmRequest {
	return EmailsAPIPutEmailConfirmRequest{
		ApiService: a,
		ctx:        ctx,
		emailUuid:  emailUuid,
	}
}

// Execute executes the request
func (a *EmailsAPIService) PutEmailConfirmExecute(r EmailsAPIPutEmailConfirmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmailsAPIService.PutEmailConfirm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/emails/{email_uuid}/confirm"
	localVarPath = strings.Replace(localVarPath, "{"+"email_uuid"+"}", url.PathEscape(parameterValueToString(r.emailUuid, "emailUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EmailsAPIUpdateAllUserEmailsRequest struct {
	ctx        context.Context
	ApiService EmailsAPI
	body       *AdminUserEmailList
	userUuid   string
}

// EmailAddressList
func (r EmailsAPIUpdateAllUserEmailsRequest) Body(body AdminUserEmailList) EmailsAPIUpdateAllUserEmailsRequest {
	r.body = &body
	return r
}

func (r EmailsAPIUpdateAllUserEmailsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAllUserEmailsExecute(r)
}

/*
UpdateAllUserEmails Update email addresses

**Required ACL**: `auth.admin.users.{user_uuid}.emails.edit` Update all of the users email address at the same time.
If an existing address is missing from the list, it will be removed. An empty list will remove all addresses. If addresses are defined, one and only one address should be main. If the confirmed field is set to none or ommited the existing value will be reused if it exists, otherwise the address will not be confirmed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid The UUID of the user
	@return EmailsAPIUpdateAllUserEmailsRequest
*/
func (a *EmailsAPIService) UpdateAllUserEmails(ctx context.Context, userUuid string) EmailsAPIUpdateAllUserEmailsRequest {
	return EmailsAPIUpdateAllUserEmailsRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
	}
}

// Execute executes the request
func (a *EmailsAPIService) UpdateAllUserEmailsExecute(r EmailsAPIUpdateAllUserEmailsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmailsAPIService.UpdateAllUserEmails")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/users/{user_uuid}/emails"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EmailsAPIUpdateUserEmailsRequest struct {
	ctx        context.Context
	ApiService EmailsAPI
	body       *UserEmailList
	userUuid   string
}

// EmailAddressList
func (r EmailsAPIUpdateUserEmailsRequest) Body(body UserEmailList) EmailsAPIUpdateUserEmailsRequest {
	r.body = &body
	return r
}

func (r EmailsAPIUpdateUserEmailsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserEmailsExecute(r)
}

/*
UpdateUserEmails Update email addresses

**Required ACL**: `auth.users.{user_uuid}.emails.edit` Update all of the users email address at the same time.
If an existing address is missing from the list, it will be removed. An empty list will remove all addresses. If addresses are defined, one and only one address should be main. All new address are created unconfirmed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid The UUID of the user
	@return EmailsAPIUpdateUserEmailsRequest
*/
func (a *EmailsAPIService) UpdateUserEmails(ctx context.Context, userUuid string) EmailsAPIUpdateUserEmailsRequest {
	return EmailsAPIUpdateUserEmailsRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
	}
}

// Execute executes the request
func (a *EmailsAPIService) UpdateUserEmailsExecute(r EmailsAPIUpdateUserEmailsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmailsAPIService.UpdateUserEmails")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/emails"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
